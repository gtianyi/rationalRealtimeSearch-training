#pragma once
#include <vector>
#include <set>
#include <functional>
#include <unordered_map>
#include "utility/PriorityQueue.h"
#include "SearchBase.h"
#include "utility/SearchResultContainer.h"
#include "expansionAlgorithms/IDAStar.h"
#include "domain/SlidingTilePuzzle.h"
#include "domain/HeavyTilePuzzle.h"
#include "domain/InverseTilePuzzle.h"
#include "domain/TreeWorld.h"
#include "domain/PancakePuzzle.h"

using namespace std;

template <class Domain>
class IDAStarSearch : public Search {
public:
    typedef typename Domain::State State;
    typedef typename Domain::Cost Cost;
    typedef typename Domain::HashState Hash;

    struct Node {
        Cost g;
        Cost h;
        Node* parent;
        State stateRep;

    public:
        Cost getGValue() const { return g; }
        Cost getHValue() const { return h; }
        Cost getFValue() const { return g + h; }
        State getState() const { return stateRep; }
        Node* getParent() const { return parent; }

        void setHValue(Cost val) { h = val; }
        void setGValue(Cost val) { g = val; }
        void setState(State s) { stateRep = s; }
        void setParent(Node* p) { parent = p; }

        Node(Cost g, Cost h, State state, Node* parent)
                : g(g), h(h), stateRep(state), parent(parent) {}

        friend std::ostream& operator<<(std::ostream& stream,
                const Node& node) {
            stream << node.getState() << endl;
            stream << "f: " << node.getFValue() << endl;
            stream << "g: " << node.getGValue() << endl;
            stream << "h: " << node.getHValue() << endl;
            stream << "action generated by: " << node.getState().getLabel()
                   << endl;
            stream << "-----------------------------------------------" << endl;
            stream << endl;
            return stream;
        }
    };

    IDAStarSearch(Domain& domain) : domain(domain){
        idastar = new IDAStar<Domain, Node>(domain, "f");
    }

    ~IDAStarSearch() { delete idastar; }

    SearchResultContainer doSearch() {
        SearchResultContainer res;

        // Get the start node
        Node* root = new Node(0,
                domain.heuristic(domain.getStartState()),
                domain.getStartState(),
                NULL);

		res.initialH = domain.heuristic(domain.getStartState());

        // Expand some nodes
        double solutionCost = idastar->search(root, res);

        calculateCost(solutionCost, res);

        return res;
    }

    void dumpClosedList(ofstream& out) {
		cout << "warning: idastar is  not for suboptimal search practice!\n";
    }

private:

    void calculateCost(double solutionCost, SearchResultContainer& res) {
        res.solutionFound = true;
        res.solutionCost = solutionCost;
    }

protected:
    Domain& domain;
    IDAStar<Domain, Node>* idastar;
};
